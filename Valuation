#importing library packages needed for the project

import numpy as np
import pandas as pd
import pandas_datareader.data as pdr
import matplotlib.pyplot as plt
%matplotlib inline

# set start and end date parameters for historical data

start_date = pd.to_datetime('2020-01-01')
end_date = pd.to_datetime('2022-12-31')

#creating an empty dictionary to store historical key (stock_ticker) and pair (stock_data) values

stocks = {}

stocks['AMD'] = yf.download('AMD', start=start_date, end=end_date)[['Adj Close']]
stocks['AAPL'] = yf.download('AAPL', start=start_date, end=end_date)[['Adj Close']]
stocks['MSFT'] = yf.download('MSFT', start=start_date, end=end_date)[['Adj Close']]
stocks['ORCL'] = yf.download('ORCL', start=start_date, end=end_date)[['Adj Close']]

#inspecting stock_ticker 'AMD'in the stocks dictionary 

stocks['AMD'].head()

#looping through the stock data to calculate normalized returns column for each stock

for stock_ticker, stock_data in stocks.items():
    adj_close = stock_data.get('Adj Close') #to directly get values from the adj close column in the dictionary 
    if adj_close is not None: #prevents index to scaler value error from days where no adj close value exits for a stock_ticker. possibly from no trades within the specified period
        first_adj_close = adj_close.iloc[0] #gets the first adj close value from each stock_ticker
        stocks['Normalized Returns'] = stock_data['Adj Close'] / first_adj_close #divide each row by the first adj close value to be stored in a new 'normalized returns' column

#looping through the stocks dictionary to assign a weight of 0.25 to each stock_ticker to create an equal weighted portfolio       
for stock_ticker, stock_data in stocks.items():
    stocks['Allocation'] = stocks['Normalized Returns'] * 0.25  
    
#looping through the stocks dictionary to assign a portfolio value of $10,000 to the each value in the allocation column
for stock_ticker, stock_data in stock_items():
stock_data['Position Value'] = stock_data['Allocation'] * 10000
        
   
#inspect dictionary to check added columns

stocks['MSFT'].head()

#looping through the stocks dictionary to create a positional value dictionary for viewing performance

positional_value = {}

for stock_ticker, stock_data in stocks.items():
positional_value[stock_ticker] = stock_data['Positional Value'] #stores stock_data's positional value values in positional value dictonary

#turning the dictionary into a dataframe to prepare values for plotting

positional_value = pd.DataFrame(data=positional_value)

#inspecting positional value dataframe

positional_value['AAPL'].head()

#adding a total column to detail positional value for all the stocks per day

positional_value['Total'] = positional_value.sum(axis=1)

#plotting the total value of all porfolio stocks with equal weight
        
plt.figure(figsize=(12,8)) #arguments for width and height

plt.plot(positional_value['Total'])

plt.title('Equally-Wieghted Portfolio Stock')
plt.ylabel('Stock Total Value')
        
#plotting the total value of each stock per day  

plt.figure(figsize=(12,8)

plt.plot(positional_value['Total'].iloc[:,0:4]) #plots the total value for stocks from column index 0 - 4

plt.title('Equally-Wieghted Portfolio Stock')
plt.ylabel('Total Value Per Stock')
        
        
#introducing metrics to further measure the portfolio perfomance 

#cummulative return - calculated by dividing the porfolio end value by the start value
end_value = position_values['Total'][-1] - #derives the portfolio's last position value
start_value = position_values['Total'][0] - #derives the portfolio's first position value
        
cummulative_return = (end_value / start_value) -1

print("The portfolio's cummulative return is: {}".format(round(cummulative_value*100,2)) + "%") 
       
#daily return - calculated by the portfolio's daily simple returns
position_values['Daily Return'] = position_values['Total'].pct_change()
        
        
#mean daily return - finds the portfolio's average daily return

mean_daily_return = position_values['Total'].mean()

print("The portfolio's mean daily return is: {:.2f}".format(mean_daily_return))

#std daily return - finds the portfolio's average daily return

std_daily_return = position_values['Total'].std()

print("The portfolio's mean daily return is: {:.2f}".format(std_daily_return))      
        
#exploring Sharpe Ratio - a risk-adjusted metric that quantifies the expected return on an asset by a given level of risk
#an assest with a higher sharpe ratio when comparing two assets, provides a higher return for the same amount of risk or same
#return for a lower amount of risk

sharpe_ratio = mean_daily_return / std_daily_return #caculated by subtracting the average portfolio return from a risk free rate and divide by the returns standard dev
                                                    #assuming a rfr of 0 here   

        
#annualizing the sharpe ratio. which is according to the rule of thumb good enough to determine a profitable portfolio    

sharpe_ratio_annualized = share_ratio * 252**0.5 #at least 252 trading days in a year and ^0.5 to find the square root
        

#creating a stock_adj_close dictionary to store adj close values for each stock while looping through the stocks dictionary

stock_adj_close = {}

for stock_ticker, stock_data in stocks.items():
stock_adj_close[stock_ticker] = stock_data['Adj Close']

#creating a dataframe from the dictionary

stock_adj_close = pd.DataFrame(data=stock_adj_close)

stock_adj_close.head() #to inspect the data frame

#creating dictionary to store adj close returns - a daily percentage change for each stock

stock_returns = stock_adj_close.pct_change()


#building a second portfolio with 10,000 scenarios with optmized (random) weight to determine the best returning asset adjusted for risk

#using np.zeros to create 10,000 weights for 10,000 scenarios

scenarios = 10000 #number of scenarios 

weights_array = np.zeros((scenarios, len(stock_returns.columns))) #creates 10,000 0 weights using the len of columns in stock_returns


#creating other arrays to store our scenario output

retuns_array = np.zeros(scenarios)
volatility_array = np.zeros(scenarios)
sharpe_array = np.zeros(scenarios)

#creating a randomly weighted portfolio

import random
random.seed(3)
np.random.seed(3)

#looping through each index in the range of scenarios to create output

for index in range(scenarios):
    numbers = np.array(np.random.random(4)) #populates each index with four random numbers in each scenario






















































        
        
        
